## 正则表达式（Regex）全面深入学习文档

> 适用读者：从零基础到进阶工程师。示例覆盖 JavaScript 与 Python，兼顾 PCRE/Java/.NET 差异。阅读顺序建议自上而下；查阅可按目录直达。

### 目录
- 基础概念与心智模型
- 字面量与元字符、转义规则
- 字符类与预定义类
- 量词：贪婪、惰性、占有式
- 锚点与边界：^ $ \b 等
- 分组、捕获、命名分组、非捕获组
- 选择与优先级
- 零宽断言（Lookaround）：先行/后行
- 模式修饰符（Flags）与内联模式
- Unicode 与文本边界（字素、单词、行）
- 替换与反向引用、命名回调替换
- 构建可维护正则：可读性、组合、注释、测试
- 性能与回溯：灾难性回溯、优化策略
- 各语言与引擎差异对照
- 常见高频场景与可直接使用的片段
- 调试与工具链
- 练习题（含参考答案思路）

---

## 基础概念与心智模型
- 正则表达式是“匹配引擎的程序”。你写的模式是“指令”，引擎逐字符执行，并在需要时回溯。
- 常见引擎：
  - JavaScript（ECMAScript）
  - PCRE（Perl Compatible Regular Expressions，广泛用于命令行工具与后端）
  - Oniguruma（Ruby 等）
  - .NET、Java 自带引擎
- 两个核心动作：
  - 匹配（match）/搜索（search）：找到文本中满足模式的片段
  - 替换（replace）：将匹配片段替换为目标字符串（可带引用/回调）

---

## 字面量与元字符、转义规则
- 元字符（需转义才按字面含义匹配）：. ^ $ * + ? ( ) [ ] { } | \
- 转义：使用 `\` 使元字符失去特殊含义，例如 `\.` 匹配“.”。
- 在字符类 `[...]` 内：
  - `-` 表示范围（置于首尾或转义可避免范围语义）
  - `^` 放在首位表示取反；非首位时为字面含义
  - `]` 需要转义或放在首位以字面含义出现

示例（JS/Python 均适用）：
```javascript
const re = /a\[b\]c\./;  // 匹配 "a[b]c." 字面量
```

---

## 字符类与预定义类
- 基本字符类：`[abc]`（a 或 b 或 c），`[^abc]`（非 a/b/c），`[a-z]`（范围）
- 预定义字符类：
  - `\d` 数字，`\D` 非数字
  - `\w` 单词字符（ASCII: [A-Za-z0-9_]；Unicode 取决于引擎与 `u`/Unicode 模式）
  - `\s` 空白字符（空格、制表、换行等），`\S` 非空白
  - `.` 任意字符（默认不含换行；DotAll/`s` 模式下包含换行）
- 常见组合：`[A-Za-z0-9_]` 等同许多环境下的 `\w`

示例：
```regex
#[A-Fa-f0-9]{6}         # 形如 #1a2b3c 的 16 进制颜色
[\w.-]+@[\w.-]+\.[A-Za-z]{2,}  # 简化版邮箱
```

---

## 量词：贪婪、惰性、占有式
- `*` 0 次或多次，`+` 1 次或多次，`?` 0 或 1 次，`{m,n}` 区间，`{m,}` 至少 m 次
- 贪婪（默认）与惰性：在量词后加 `?` 变为惰性
  - `.*` 尽可能多；`.*?` 尽可能少
- 占有式量词（阻止回溯）：`*+` `++` `?+` `{m,n}+`（JS 不支持，PCRE/Java/.NET 支持）

对比：
```regex
<a>.*</a>     # 贪婪，可能跨越多个标签
<a>.*?</a>    # 惰性，匹配最短闭合对
\d++         # 占有式（非 JS），配合复杂周边可避免回溯
```

---

## 锚点与边界
- `^` 行首，`$` 行尾（多行 `m` 模式改变行为）
- `\A` 文本开始、`\Z` 文本结束（PCRE/Oniguruma/.NET；不受多行影响）
- 单词边界：`\b`，非单词边界：`\B`（是否 Unicode 感知依赖引擎与模式）
- `\G` 上一次匹配结束位置（PCRE/Perl/Oniguruma 等）

---

## 分组、捕获与命名
- 捕获组：`( ... )`，按出现次序编号 `\1`, `\2`...
- 非捕获组：`(?: ... )`，仅分组不记录
- 命名捕获：
  - JS/PCRE/Java/.NET：`(?<name>...)`，回溯 `\k<name>`（替换中也可用 `$<name>`/`\k<name>`）
  - Python：`(?P<name>...)`，回溯 `(?P=name)`；替换可用 `\g<name>`

示例（JS）：
```javascript
const re = /(?<user>[\w.-]+)@(?<host>[\w.-]+)/;
const m = 'a.b@example.com'.match(re);
// m.groups.user === 'a.b', m.groups.host === 'example.com'
```

---

## 选择与优先级
- 使用 `|` 进行选择，优先匹配左侧；与量词/分组组合时注意优先级
```regex
(?:https?|ftp)://[^\s/$.?#].[^\s]*
```

---

## 零宽断言（Lookaround）
- 先行断言：`(?=...)` 肯定先行，`(?!...)` 否定先行
- 后行断言：`(?<=...)` 肯定后行，`(?<!...)` 否定后行
- 断言不消耗字符，仅检查位置条件
- 兼容性：
  - JS 现代环境支持先行/后行（含变长后行，老旧环境可能不支持）
  - Python 原生仅固定长度后行（变长需第三方引擎，如 `regex` 模块）

示例：
```regex
\w+(?=\.)                 # 点号前的单词
(?<=\$)\d+(?:\.\d+)?     # $ 后的金额
(?!.*password).*admin      # 整体不得含 password，且含 admin
```

---

## 模式修饰符（Flags）与内联
- JavaScript：
  - `i` 忽略大小写，`g` 全局，`m` 多行，`s` DotAll，`u` Unicode，`y` 粘连
- Python：`re.I`/`IGNORECASE`，`M` 多行，`S` DotAll，`X` verbose，`A` ASCII-only，`L` locale
- PCRE/Java/.NET 内联：`(?i) (?m) (?s) (?x)` 启用；`(?-i)` 组内关闭

内联示例：
```regex
(?is)^[a-z0-9_.-]+$    # 同时开启忽略大小写与 dotAll（PCRE/Java/.NET）
```

---

## Unicode 与文本边界
- `u`/Unicode 模式影响：
  - `\w`、`\b` 的定义（是否只 ASCII 还是全 Unicode）
  - 码点处理（代理对、组合字符）
- 字素簇（grapheme cluster）：一个用户可见字形可能由多个码点组成（含“变音符”）
  - PCRE/Oniguruma 支持 `\X` 匹配一个字素簇（JS/Python 原生不支持）
- 行边界：`^`/`$` 与 `\R`（PCRE 的通用换行）

JS 处理 Unicode 字符串的建议：
```javascript
// 使用 u 标志，并用字符类覆盖更多字符集
/^[\p{L}\p{N}_]+$/u   // 依赖 Unicode 属性类（现代 JS 支持）
```

Python 建议：
```python
import re
re_u = re.compile(r"^\w+$", re.UNICODE)
```

---

## 替换与反向引用
- JS：`String.prototype.replace`
  - `$1` `$2`...，`$<name>` 引用命名组
  - 回调替换 `(match, p1, p2, ..., offset, input, groups) => string`
- Python：`re.sub`
  - `\\1` `\\g<name>` 引用
  - 回调替换：传函数 `re.sub(pattern, repl_func, text)`

示例（JS）
```javascript
const re = /(?<area>\d{3})-(?<num>\d{4})/g;
"010-1234 021-5678".replace(re, '+86 $<area> $<num>');
```

示例（Python）
```python
import re
re.sub(r"(?P<area>\d{3})-(?P<num>\d{4})", r"+86 \g<area> \g<num>", "010-1234 021-5678")
```

---

## 构建可维护正则
- 可读性优先：拆分子模式，命名分组，使用非捕获组避免无意的编号位移
- 分步组合：
```javascript
const localPart = `(?:[\w.+-]+)`;
const host = `(?:[\w-]+(?:\.[\w-]+)+)`;
const email = new RegExp(`^${localPart}@${host}$`);
```
- 注释模式（verbose）：
  - Python：`re.X` 允许空白与注释
  - PCRE/Java/.NET：`(?x)` 组内启用
```python
re.compile(r"""
  ^                 # 开头
  [\w.+-]+         # 本地部分
  @
  [\w-]+(\.[\w-]+)+  # 主机
  $                 # 结尾
""", re.X)
```
- 测试：为复杂正则建立单测用例与负例用例。

---

## 性能与回溯（避免灾难性回溯）
- 典型雷区：相邻的可回溯量词组合如 `(.*)+`、`(a+)+`、`(.*a)*` 在特定输入上指数级回溯
- 识别信号：CPU 飙高、请求卡死、调试工具显示大量回溯帧
- 优化策略：
  - 具体化点号：用更窄的字符类代替 `.*`
  - 使用惰性量词并配合锚点/断言限定
  - 使用占有式量词或原子组（阻止回溯；JS 不支持原子组/占有式）
  - 分而治之：拆分匹配为多段

示例（PCRE/Java/.NET 可用原子组）：
```regex
(?>[^<]+)*<a>.*?</a>   # 将前缀消费设为原子，避免回溯风暴
```

JS 替代（用更具体的类 + 惰性）：
```regex
[^<]*<a>.*?</a>
```

---

## 各语言与引擎差异对照（要点）
- JavaScript：
  - 不支持占有式量词与原子组
  - 现代支持后行断言、Unicode 属性类（`\p{…}`）
  - `s`/DotAll、`y`/sticky 可用
- Python `re`：
  - 后行固定长度限制
  - `re.X` 注释模式强大
  - 无占有式量词；有具备回溯控制的第三方 `regex` 模块
- PCRE/Java/.NET：
  - 支持占有式量词与原子组
  - 支持内联模式开关，断言全面
  - PCRE 具 `\R`、`\X` 等扩展

---

## 常见高频场景片段（可直接用）
- 邮箱（宽松版，生产建议使用库或 RFC 级实现）：
```regex
^[\w.+-]+@[\w-]+(?:\.[\w-]+)+$
```
- URL（极简版，含 http/https/ftp）：
```regex
^(?:https?|ftp)://[^\s/$.?#].[^\s]*$
```
- 中国大陆手机号（1 开头 3-9 段）：
```regex
^1[3-9]\d{9}$
```
- IPv4：
```regex
^(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)){3}$
```
- 十六进制颜色：
```regex
^#(?:[A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$
```
- 日期（YYYY-MM-DD，未校验闰年与合法性）：
```regex
^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$
```
- 去除 HTML 标签（简化示意，严肃解析请用解析器）：
```regex
<[^>]+>
```
- 提取标签内文本（最短匹配）：
```regex
<title>(.*?)</title>
```
- 仅在单词边界替换某词（JS）：
```javascript
str.replace(/\bfoo\b/g, 'bar')
```

---

## 调试与工具链
- 交互式可视化工具（支持高亮、回溯可视化、解释）：
  - Regex101（PCRE/JS）：可保存与分享用例
  - Debuggex、RegExr：图形化解释
- 编辑器集成：VS Code 正则查找、语言服务扩展
- 基准与护栏：为核心正则写单测与性能基准，防止回归与卡死

---

## 练习题（附思路）
1) 提取文本中所有形如 `v1.2.3` 的语义化版本号（主、次、补丁均为非负整数）
```regex
\bv(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)\b
```
思路：使用非捕获组与 0/非零开头的分支避免前导零。

2) 匹配由逗号分隔的值，但忽略引号内的逗号：
（提示：使用先行/后行断言统计偶数个引号或使用解析而非正则）

3) 匹配 markdown 粗体 `**bold**` 并替换为 HTML `<strong>`：
```javascript
text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
```
思路：惰性量词防止跨段落吞噬；更严格可限制不跨换行。

4) 提取 HTML 中所有链接的 href（演示用，生产请用解析器）：
```regex
<a[^>]+href=["']?([^"'\s>]+)["']?[^>]*>
```

5) 校验强密码（至少 8 位，含大小写字母与数字）：
```regex
^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$
```

---

## 参考与延伸阅读
- “Regular Expressions” in MDN（JavaScript 规范与示例清晰）
- Jeffrey Friedl《精通正则表达式》（深入机制与实践）
- 各语言官方 `re`/`Regex` 文档与 PCRE 参考手册

---

## 附：语言示例速览
### JavaScript
```javascript
// 搜索所有匹配
const re = /(\w+)=(\w+)/g;
for (const m of 'a=1 b=2'.matchAll(re)) {
  console.log(m[1], m[2]);
}

// 命名组与替换
const r = /(?<k>\w+)=(?<v>\w+)/g;
'a=1 b=2'.replace(r, '$<v>->$<k>'); // 1->a 2->b
```

### Python
```python
import re
re_pat = re.compile(r"(?P<k>\w+)=(?P<v>\w+)")
for m in re_pat.finditer("a=1 b=2"):
    print(m.group('k'), m.group('v'))

re_pat.sub(r"\g<v>->\g<k>", "a=1 b=2")  # 1->a 2->b
```


