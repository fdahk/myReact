# 时间单位
| 单位 | 换算 | 说明 |
|------|------|------|
| 秒 (s) | 1s | 基准单位 |
| 毫秒 (ms) | 1s = 1,000 ms | 网络请求延迟通常在此级别 |
| 微秒 (μs) | 1s = 1,000,000 μs | 内存访问延迟在此级别 |
| 纳秒 (ns) | 1s = 10^9 ns | CPU 单条指令执行时间 |
| 皮秒 (ps) | 1s = 10^12 ps | CPU 内部信号传输时间 |

# CPU 时钟周期 (Clock Cycle)
CPU 执行操作的最小时间单位。现代 CPU 主频 3GHz 意味着每秒 30 亿个时钟周期，即每个周期约 0.33 纳秒。一条简单指令可能需要 1-3 个时钟周期完成。

# 内存总线 (Memory Bus)
CPU 与内存之间传输数据的通道。就像一条高速公路，同一时刻只能有一个数据包通过特定的"车道"。当多个 CPU 核心同时请求访问内存时，总线会对请求进行排队和调度。

# 总线仲裁 (Bus Arbitration)
当多个设备（如多个 CPU 核心）同时请求使用总线时，硬件层面决定谁先使用的机制。常见策略：
- **轮询仲裁**：按顺序轮流授权
- **优先级仲裁**：高优先级设备优先
- **FCFS**：先到先服务

# 缓存一致性协议 - MESI
多核 CPU 中确保各核心缓存数据一致的协议。MESI 是四种缓存行状态的首字母：
| 状态 | 含义 | 说明 |
|------|------|------|
| **M** (Modified) | 已修改 | 数据被当前核心修改，与内存不一致 |
| **E** (Exclusive) | 独占 | 数据只在当前核心缓存，与内存一致 |
| **S** (Shared) | 共享 | 数据可能在多个核心缓存中 |
| **I** (Invalid) | 无效 | 缓存行数据无效，需重新从内存读取 |

当一个核心要修改共享数据时，必须先通知其他核心将对应缓存行置为 Invalid，这个过程是原子的。

# 原子操作 (Atomic Operation)
不可分割的操作，要么完全执行，要么完全不执行，中间不会被其他操作打断。
```c
// 非原子操作（可能被打断）
count = count + 1;  // 实际是：读取 → 加1 → 写入，三步操作

// 原子操作（不可被打断）
atomic_increment(&count);  // 硬件保证整个过程不被中断
```

# CAS (Compare-And-Swap)
一种原子操作指令，包含三个操作数：内存地址 V、期望值 A、新值 B。
- 如果 V 处的值等于 A，则将 V 处的值更新为 B
- 否则不做任何操作
- 无论是否更新，都返回 V 处的原值

```c
// CAS 伪代码
int CAS(int* addr, int expected, int new_value) {
    int old = *addr;
    if (old == expected) {
        *addr = new_value;
    }
    return old;  // 返回原值，调用者可判断是否成功
}
```
整个过程由 CPU 硬件保证原子性。

# XCHG (Exchange)
另一种原子指令，将寄存器的值与内存地址的值互换。常用于实现自旋锁：
```asm
; 尝试获取锁
mov eax, 1
xchg eax, [lock_addr]  ; 原子交换
; 如果 eax 变成 0，说明之前锁是空闲的，获取成功
```

# Mutex (互斥锁)
Mutual Exclusion 的缩写，一种同步原语，确保同一时刻只有一个线程能访问共享资源。
- **加锁 (lock)**：获取锁，如果锁被占用则等待
- **解锁 (unlock)**：释放锁，允许其他线程获取

# 行锁 vs 表锁
| 类型 | 锁定范围 | 并发性 | 开销 | 适用场景 |
|------|----------|--------|------|----------|
| **行锁** | 单行数据 | 高 | 较大 | 高并发 OLTP |
| **表锁** | 整张表 | 低 | 较小 | 批量操作、DDL |

```sql
-- 行锁示例（InnoDB）
SELECT * FROM users WHERE id = 1 FOR UPDATE;  -- 只锁 id=1 这一行

-- 表锁示例
LOCK TABLES users WRITE;  -- 锁整张表
```

# 自旋 (Spinning)
获取锁失败时，线程不立即休眠，而是循环检查锁状态（"原地转圈"）。
- **优点**：避免线程上下文切换开销
- **缺点**：持续占用 CPU 资源
- **适用**：锁持有时间很短的场景

```c
// 自旋锁
while (atomic_load(&lock) != 0) {
    // 空循环，等待锁释放
}
```

# 休眠等待 vs 自旋等待
| 方式 | CPU 占用 | 切换开销 | 适用场景 |
|------|----------|----------|----------|
| **自旋** | 持续 100% | 无 | 锁持有时间 < 上下文切换时间 |
| **休眠** | 0% | 较大 | 锁持有时间较长 |

现代操作系统通常采用**自适应自旋**：先自旋一小段时间，如果还获取不到锁再进入休眠。


# InnoDB 是 MySQL 数据库的默认存储引擎（从 MySQL 5.5 开始）。
什么是存储引擎？
MySQL 采用插件式架构，存储引擎负责数据的存储和提取。不同引擎有不同特性：
┌─────────────────────────────────────┐
│           MySQL Server              │
│  (SQL 解析、优化器、连接管理等)       │
├─────────────────────────────────────┤
│          存储引擎接口                │
├──────────┬──────────┬───────────────┤
│  InnoDB  │  MyISAM  │  Memory  │ ...│
└──────────┴──────────┴───────────────┘

InnoDB 核心特性
特性	说明
事务支持 (ACID)	支持提交、回滚、崩溃恢复
行级锁	高并发下性能好（对比 MyISAM 的表锁）
外键约束	保证数据完整性
MVCC	多版本并发控制，读写不阻塞
聚簇索引	数据按主键顺序存储，主键查询极快
崩溃恢复	通过 redo log 保证数据不丢失

InnoDB vs MyISAM（旧默认引擎）
对比项	InnoDB	MyISAM
事务	✅ 支持	❌ 不支持
锁粒度	行锁	表锁
外键	✅ 支持	❌ 不支持
崩溃恢复	✅ 安全	❌ 易损坏
全文索引	✅ (5.6+)	✅
适用场景	高并发、事务场景	只读、大量查询
