# 迁移异常、数据库异常，有可能是因为字符集定义差异
CREATE DATABASE paaawow CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;




# 从计算机底层原理来解释为什么"真正的同一时刻"在物理上不可能发生，以及数据库如何处理"几乎同时"的请求。
1. 计算机中不存在"绝对同时"
硬件层面的序列化
CPU 核心执行指令的最小单位是 CPU 时钟周期（纳秒级）内存总线访问是串行化的 —— 同一时刻只有一个请求能访问同一内存地址
即使是多核 CPU，当两个核心同时尝试访问/修改同一内存位置时，硬件层面会通过 缓存一致性协议（如 MESI） 和 总线仲裁 强制将它们序列化。
原子操作的硬件保证
CAS (Compare-And-Swap) 指令在 CPU 层面是原子的锁定内存总线 → 读取 → 比较 → 写入 → 解锁这个过程中其他 CPU 核心无法介入
2. 数据库锁的实现原理
数据库的行锁/表锁最终都依赖于操作系统的互斥原语（mutex），而 mutex 的核心就是 原子操作：
// 简化的锁获取逻辑（伪代码）
while (true) {    
    // 原子操作：尝试将 lock 从 0 改为 1    
    if (atomic_compare_and_swap(&lock, 0, 1) == SUCCESS) {       
         // 获取锁成功        
         break;    
        }    
    // 获取失败，自旋或休眠等待
    }
3. "同一时刻"的两个请求会怎样？
假设请求 A 和请求 B 在纳秒级别内同时到达：
时间线（放大到纳秒级）：
────────────────────────────────────────────────────
     │                    │
   请求A                请求B
   到达                  到达
     │                    │
     ▼                    ▼
   [CPU核心1]          [CPU核心2]
   执行 CAS             执行 CAS
     │                    │
     ▼                    ▼
   ┌─────────────────────────────────────┐
   │     内存总线仲裁（硬件强制序列化）    │
   │  只有一个 CAS 能成功，另一个失败      │
   └─────────────────────────────────────┘
     │                    │
     ▼                    ▼
   获取锁成功           获取锁失败
   执行操作              进入等待队列
4. 关键点总结
层级	机制	保证
CPU 硬件	总线仲裁 + 缓存一致性协议	同一内存地址的访问被强制串行化
操作系统	原子指令（CAS/XCHG）	锁状态的读写是不可分割的
数据库	基于 OS 原语的锁管理	事务获取锁的过程是原子的
5. 总结
> "如果两个请求就是同一时刻发生的呢？"
物理上不可能"同一时刻"：
即使网络包在同一微秒到达服务器
即使两个线程在同一纳秒执行锁请求
硬件总线仲裁会在皮秒级别决定谁先谁后
这不是"延迟"的问题，而是硬件层面的确定性裁决。就像两个人同时按下同一个物理按钮——分子层面总有一个先接触到。
> "延迟再短不也是延迟？"
这个"延迟"不是可被利用的漏洞，而是物理规律决定的序列化。数据库不需要"等待"来判断谁先——硬件在执行原子操作的那一刻就已经决定了结果。
类比：两辆车"同时"到达单行道入口，但入口物理上只能容纳一辆车。不存在"两辆车同时通过"的状态——物理空间本身就是互斥的。CPU 的原子操作也是如此。

---





为什么“索引太多会让优化器选择困难”——讲透（原理向）
数据库执行一条 SQL 时，通常会走：
解析 SQL → 生成多种执行计划候选 → 优化器选择成本最低的计划 → 执行
1）索引多为什么会“难选”？
每多一个索引，优化器就多一种“可能走的路径”
用哪个索引？
用单列索引还是联合索引？
是否做 index merge（多个索引合并）？
走索引后是否需要回表？
是否改用全表扫描反而更快？
选择空间变大，优化器需要依赖统计信息（基数、选择性、分布）估算成本
统计信息不准时，就更容易选错。
2）索引多的真实代价不止“难选”
写入成本上升：每次 INSERT/UPDATE/DELETE 需要维护更多 B+Tree
空间成本上升
缓存压力：索引页占用 buffer pool，挤掉热点数据页
计划不稳定：数据分布变化后，原本合适的索引变得不合适，性能抖动
3）什么时候索引多尤其容易出问题（扩展）
很多“低选择性”列都建了索引（如 gender/status/is_deleted），优化器可能误判“用索引更快”
联合索引设计不合理（列顺序不符合查询条件）
统计信息长时间不更新（导致估算偏差）

---


通用 SQL 查询的执行顺序（核心规则）
所有 SQL 查询的执行都遵循「从数据源到结果集」的固定逻辑顺序，与书写顺序无关，核心步骤如下：
执行顺序	子句 / 操作	作用
1	FROM	确定查询的数据源（表 / 视图等），加载原始数据行。
2	WHERE	对 FROM 加载的原始行进行行级过滤，仅保留符合条件的记录。
3	GROUP BY	对 WHERE 过滤后的行进行分组，将相同特征的行合并为一个组。
4	HAVING	对 GROUP BY 生成的分组进行组级过滤，仅保留符合条件的分组。
5	SELECT	选择要输出的列（包括聚合函数计算、字段别名定义）。
6	ORDER BY	对 SELECT 输出的结果集进行排序。


# MySQL 全面知识点总结

## 目录
- [一、数据库基础操作](#一数据库基础操作)
- [二、数据类型](#二数据类型)
- [三、表操作](#三表操作)
- [四、约束详解](#四约束详解)
- [五、数据操作CRUD](#五数据操作crud)
- [六、查询详解](#六查询详解)
- [七、索引](#七索引)
- [八、视图](#八视图)
- [九、存储过程与函数](#九存储过程与函数)
- [十、触发器](#十触发器)
- [十一、事务](#十一事务)
- [十二、用户与权限](#十二用户与权限)
- [十三、常用函数](#十三常用函数)
- [十四、性能优化](#十四性能优化)

---

## 一、数据库基础操作

### 1.1 数据库管理

```sql
-- 查看所有数据库
SHOW DATABASES;

-- 创建数据库（推荐指定字符集）
CREATE DATABASE mydb;
CREATE DATABASE mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE DATABASE IF NOT EXISTS mydb;  -- 不存在时才创建

-- 查看当前数据库
SELECT DATABASE();

-- 查看数据库创建语句
SHOW CREATE DATABASE mydb;

-- 修改数据库字符集
ALTER DATABASE mydb CHARACTER SET utf8mb4;

-- 删除数据库
DROP DATABASE mydb;
DROP DATABASE IF EXISTS mydb;  -- 存在时才删除
```

### 1.2 系统信息查询

```sql
SELECT VERSION();           -- MySQL版本
SELECT USER();              -- 当前用户
SELECT NOW();               -- 当前时间
SHOW VARIABLES LIKE 'character%';  -- 字符集配置
SHOW VARIABLES LIKE 'max_connections';  -- 最大连接数
SHOW PROCESSLIST;           -- 当前连接/进程
SHOW STATUS;                -- 服务器状态
```

---

## 二、数据类型

### 2.1 数值类型

| 类型 | 字节 | 范围 | 用途 |
|------|------|------|------|
| `TINYINT` | 1 | -128~127 | 小整数/布尔 |
| `SMALLINT` | 2 | -32768~32767 | 小整数 |
| `MEDIUMINT` | 3 | -8388608~8388607 | 中整数 |
| `INT/INTEGER` | 4 | -21亿~21亿 | **常用整数** |
| `BIGINT` | 8 | -922亿亿~922亿亿 | 大整数/ID |
| `FLOAT` | 4 | | 单精度浮点 |
| `DOUBLE` | 8 | | 双精度浮点 |
| `DECIMAL(M,D)` | | | **精确小数（金额用）** |

```sql
-- 示例
age TINYINT UNSIGNED,        -- 无符号 0~255
price DECIMAL(10,2),         -- 总10位，小数2位
id BIGINT AUTO_INCREMENT     -- 大整数自增
```

### 2.2 字符串类型

| 类型 | 最大长度 | 特点 | 用途 |
|------|----------|------|------|
| `CHAR(n)` | 255字符 | 定长，右补空格 | 固定长度（手机号、MD5） |
| `VARCHAR(n)` | 65535字节 | **变长，按实际存储** | **最常用** |
| `TEXT` | 65535字节 | 大文本 | 文章内容 |
| `MEDIUMTEXT` | 16MB | 更大文本 | |
| `LONGTEXT` | 4GB | 超大文本 | |
| `ENUM` | | 枚举值 | 固定选项 |
| `SET` | | 集合值 | 多选项 |

```sql
-- 示例
name VARCHAR(50) NOT NULL,
gender ENUM('男', '女'),
status ENUM('待选', '已选', '完成'),
phone CHAR(11),
content TEXT
```

### 2.3 日期时间类型

| 类型 | 格式 | 范围 | 用途 |
|------|------|------|------|
| `DATE` | YYYY-MM-DD | 1000~9999年 | 日期 |
| `TIME` | HH:MM:SS | | 时间 |
| `DATETIME` | YYYY-MM-DD HH:MM:SS | 1000~9999年 | **日期时间** |
| `TIMESTAMP` | YYYY-MM-DD HH:MM:SS | 1970~2038年 | 时间戳（自动更新） |
| `YEAR` | YYYY | 1901~2155 | 年份 |

```sql
-- 示例
birthday DATE,
login_time DATETIME,
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
```

### 2.4 其他类型

```sql
BLOB        -- 二进制大对象
JSON        -- JSON数据（MySQL 5.7+）
BOOLEAN     -- 布尔值（实际是TINYINT(1)）
```

---

## 三、表操作

### 3.1 创建表

```sql
-- 基础语法
CREATE TABLE 表名 (
    列名 数据类型 [约束],
    列名 数据类型 [约束],
    ...
    [表级约束]
) ENGINE=InnoDB COMMENT='表注释';

-- 完整示例
CREATE TABLE student (
    student_no VARCHAR(20) PRIMARY KEY COMMENT '学号',
    name VARCHAR(50) NOT NULL COMMENT '姓名',
    gender ENUM('男', '女') NOT NULL DEFAULT '男' COMMENT '性别',
    age TINYINT UNSIGNED CHECK (age >= 0 AND age <= 150),
    email VARCHAR(100) UNIQUE,
    major_id INT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_student_major FOREIGN KEY (major_id) 
        REFERENCES major(major_id) ON DELETE SET NULL
) ENGINE=InnoDB COMMENT='学生表';

-- 复制表结构
CREATE TABLE new_table LIKE old_table;

-- 复制表结构和数据
CREATE TABLE new_table AS SELECT * FROM old_table;
```

### 3.2 查看表信息

```sql
SHOW TABLES;                    -- 查看所有表
SHOW TABLES LIKE 'student%';    -- 模糊匹配表名
DESC student;                   -- 查看表结构
DESCRIBE student;               -- 同上
SHOW COLUMNS FROM student;      -- 同上
SHOW CREATE TABLE student;      -- 查看建表语句
SHOW TABLE STATUS LIKE 'student';  -- 查看表状态
SHOW INDEX FROM student;        -- 查看索引
```

### 3.3 修改表结构

```sql
-- 添加列
ALTER TABLE student ADD COLUMN phone VARCHAR(20);
ALTER TABLE student ADD COLUMN id_card VARCHAR(18) AFTER name;  -- 指定位置
ALTER TABLE student ADD COLUMN seq INT FIRST;  -- 添加到第一列

-- 修改列类型
ALTER TABLE student MODIFY COLUMN phone VARCHAR(30);
ALTER TABLE student MODIFY COLUMN phone VARCHAR(30) NOT NULL DEFAULT '';

-- 修改列名和类型
ALTER TABLE student CHANGE COLUMN phone tel VARCHAR(30);

-- 删除列
ALTER TABLE student DROP COLUMN phone;

-- 添加约束
ALTER TABLE student ADD CONSTRAINT uk_email UNIQUE (email);
ALTER TABLE student ADD CONSTRAINT chk_age CHECK (age >= 0);
ALTER TABLE student ADD PRIMARY KEY (student_no);
ALTER TABLE student ADD CONSTRAINT fk_major 
    FOREIGN KEY (major_id) REFERENCES major(major_id);

-- 删除约束
ALTER TABLE student DROP INDEX uk_email;       -- 删除唯一约束
ALTER TABLE student DROP CHECK chk_age;        -- 删除检查约束
ALTER TABLE student DROP PRIMARY KEY;          -- 删除主键
ALTER TABLE student DROP FOREIGN KEY fk_major; -- 删除外键

-- 修改表名
RENAME TABLE old_name TO new_name;
ALTER TABLE old_name RENAME TO new_name;

-- 修改表注释
ALTER TABLE student COMMENT = '学生信息表';

-- 修改表的存储引擎
ALTER TABLE student ENGINE = InnoDB;
```

### 3.4 删除表

```sql
DROP TABLE student;
DROP TABLE IF EXISTS student;
DROP TABLE student, teacher;  -- 删除多个表

-- 清空表数据（保留结构）
TRUNCATE TABLE student;  -- 快速清空，不可回滚，自增归零
DELETE FROM student;     -- 逐行删除，可回滚，自增不归零
```

---

## 四、约束详解

### 4.1 主键约束 (PRIMARY KEY)

```sql
-- 建表时定义
CREATE TABLE t1 (
    id INT PRIMARY KEY,              -- 列级定义
    name VARCHAR(50)
);

CREATE TABLE t2 (
    id INT,
    name VARCHAR(50),
    PRIMARY KEY (id)                 -- 表级定义
);

-- 联合主键
CREATE TABLE order_detail (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)  -- 联合主键
);

-- 自增主键（代理主键）
CREATE TABLE t3 (
    id INT PRIMARY KEY AUTO_INCREMENT,  -- 自增
    name VARCHAR(50)
);
```

**主键特点**：
- 唯一标识每一行
- 不能为 NULL
- 一个表只能有一个主键（但可以是联合主键）

### 4.2 外键约束 (FOREIGN KEY)

```sql
CREATE TABLE student (
    student_no VARCHAR(20) PRIMARY KEY,
    major_id INT,
    
    -- 外键约束
    CONSTRAINT fk_student_major 
        FOREIGN KEY (major_id) 
        REFERENCES major(major_id)
        ON DELETE RESTRICT      -- 删除策略
        ON UPDATE CASCADE       -- 更新策略
);
```

**外键策略**：
| 策略 | ON DELETE | ON UPDATE | 说明 |
|------|-----------|-----------|------|
| `RESTRICT` | 阻止删除 | 阻止更新 | **默认**，有引用则禁止 |
| `CASCADE` | 级联删除 | 级联更新 | 自动删除/更新关联记录 |
| `SET NULL` | 设为NULL | 设为NULL | 关联字段设为NULL |
| `NO ACTION` | 同RESTRICT | 同RESTRICT | MySQL中等同RESTRICT |

### 4.3 唯一约束 (UNIQUE)

```sql
-- 单列唯一
CREATE TABLE user (
    id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE,  -- 列级
    phone VARCHAR(20),
    UNIQUE (phone)              -- 表级
);

-- 联合唯一
CREATE TABLE major (
    major_id INT PRIMARY KEY,
    major_name VARCHAR(50),
    dept_id INT,
    CONSTRAINT uk_dept_major UNIQUE (dept_id, major_name)  -- 组合唯一
);
```

**UNIQUE vs PRIMARY KEY**：
| 特性 | PRIMARY KEY | UNIQUE |
|------|-------------|--------|
| 能否为NULL | 不能 | 可以（但NULL也只能一个） |
| 数量限制 | 只能一个 | 可以多个 |
| 自动创建索引 | 聚簇索引 | 普通索引 |

### 4.4 非空约束 (NOT NULL)

```sql
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,  -- 不能为空
    age INT                     -- 可以为空
);
```

### 4.5 默认值约束 (DEFAULT)

```sql
CREATE TABLE user (
    id INT PRIMARY KEY,
    status INT DEFAULT 0,
    gender ENUM('男','女') DEFAULT '男',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 4.6 检查约束 (CHECK)

```sql
-- MySQL 8.0+ 支持
CREATE TABLE user (
    id INT PRIMARY KEY,
    age INT CHECK (age >= 0 AND age <= 150),
    gender CHAR(1) CHECK (gender IN ('M', 'F')),
    CONSTRAINT chk_age CHECK (age >= 18)
);
```

---

## 五、数据操作CRUD

### 5.1 插入数据 (INSERT)

```sql
-- 插入单行（指定列）
INSERT INTO student (student_no, name, gender) 
VALUES ('S001', '张三', '男');

-- 插入单行（全部列）
INSERT INTO student VALUES ('S002', '李四', '女', 20, 'lisi@edu.cn', 1, NOW());

-- 插入多行
INSERT INTO student (student_no, name, gender) VALUES
('S003', '王五', '男'),
('S004', '赵六', '女'),
('S005', '钱七', '男');

-- 从查询结果插入
INSERT INTO student_backup (student_no, name)
SELECT student_no, name FROM student WHERE gender = '男';

-- 插入或更新（主键/唯一键冲突时更新）
INSERT INTO student (student_no, name, age)
VALUES ('S001', '张三', 21)
ON DUPLICATE KEY UPDATE age = VALUES(age);

-- 插入忽略（冲突时忽略）
INSERT IGNORE INTO student (student_no, name) VALUES ('S001', '张三');

-- 替换插入（存在则删除后插入）
REPLACE INTO student (student_no, name) VALUES ('S001', '张三新');
```

### 5.2 查询数据 (SELECT)

```sql
-- 基础查询
SELECT * FROM student;
SELECT student_no, name, gender FROM student;
SELECT DISTINCT major_id FROM student;  -- 去重

-- 条件查询
SELECT * FROM student WHERE gender = '男';
SELECT * FROM student WHERE age >= 18 AND age <= 25;
SELECT * FROM student WHERE age BETWEEN 18 AND 25;
SELECT * FROM student WHERE major_id IN (1, 2, 3);
SELECT * FROM student WHERE major_id NOT IN (1, 2);
SELECT * FROM student WHERE name LIKE '张%';      -- 以张开头
SELECT * FROM student WHERE name LIKE '%三';      -- 以三结尾
SELECT * FROM student WHERE name LIKE '%明%';     -- 包含明
SELECT * FROM student WHERE name LIKE '张_';      -- 张+一个字符
SELECT * FROM student WHERE email IS NULL;
SELECT * FROM student WHERE email IS NOT NULL;
SELECT * FROM student WHERE NOT (age > 20);

-- 排序
SELECT * FROM student ORDER BY age;              -- 升序（默认）
SELECT * FROM student ORDER BY age ASC;          -- 升序
SELECT * FROM student ORDER BY age DESC;         -- 降序
SELECT * FROM student ORDER BY major_id, age DESC;  -- 多字段排序

-- 限制结果
SELECT * FROM student LIMIT 10;           -- 前10条
SELECT * FROM student LIMIT 5, 10;        -- 跳过5条取10条
SELECT * FROM student LIMIT 10 OFFSET 5;  -- 同上

-- 别名
SELECT student_no AS '学号', name AS '姓名' FROM student AS s;
```

### 5.3 更新数据 (UPDATE)

```sql
-- 更新单个字段
UPDATE student SET age = 21 WHERE student_no = 'S001';

-- 更新多个字段
UPDATE student SET age = 22, email = 'new@edu.cn' WHERE student_no = 'S001';

-- 批量更新
UPDATE student SET status = 1 WHERE major_id = 1;

-- 基于计算更新
UPDATE product SET price = price * 0.9;  -- 打9折

-- 关联更新
UPDATE student s
JOIN major m ON s.major_id = m.major_id
SET s.dept_name = m.dept_name
WHERE m.major_id = 1;

-- 安全更新（防止全表更新）
SET SQL_SAFE_UPDATES = 1;  -- 开启后，UPDATE/DELETE必须带WHERE
```

### 5.4 删除数据 (DELETE)

```sql
-- 删除指定行
DELETE FROM student WHERE student_no = 'S001';

-- 批量删除
DELETE FROM student WHERE major_id = 1;

-- 关联删除
DELETE s FROM student s
JOIN major m ON s.major_id = m.major_id
WHERE m.dept_id = 1;

-- 清空表
DELETE FROM student;         -- 可回滚，自增不归零
TRUNCATE TABLE student;      -- 不可回滚，自增归零，更快
```

---

## 六、查询详解

### 6.1 聚合函数

```sql
SELECT COUNT(*) FROM student;                    -- 总行数
SELECT COUNT(email) FROM student;                -- 非NULL数量
SELECT COUNT(DISTINCT major_id) FROM student;    -- 去重计数
SELECT SUM(age) FROM student;                    -- 求和
SELECT AVG(age) FROM student;                    -- 平均值
SELECT MAX(age) FROM student;                    -- 最大值
SELECT MIN(age) FROM student;                    -- 最小值
SELECT GROUP_CONCAT(name) FROM student;          -- 拼接成字符串
SELECT GROUP_CONCAT(name ORDER BY age SEPARATOR ', ') FROM student;
```

### 6.2 分组查询 (GROUP BY)

```sql
-- 基础分组
SELECT gender, COUNT(*) AS '人数' FROM student GROUP BY gender;

-- 多字段分组
SELECT major_id, gender, COUNT(*) 
FROM student 
GROUP BY major_id, gender;

-- 分组后筛选（HAVING）
SELECT major_id, COUNT(*) AS cnt 
FROM student 
GROUP BY major_id 
HAVING cnt > 5;                    -- HAVING 用于分组后筛选
                                   -- WHERE 用于分组前筛选

-- 完整执行顺序示例
SELECT major_id, COUNT(*) AS cnt   -- 5. 选择列
FROM student                        -- 1. 从表
WHERE age >= 18                     -- 2. 行筛选
GROUP BY major_id                   -- 3. 分组
HAVING cnt > 5                      -- 4. 分组筛选
ORDER BY cnt DESC                   -- 6. 排序
LIMIT 10;                           -- 7. 限制
```

### 6.3 多表连接 (JOIN)

```sql
-- 内连接（只返回匹配的行）
SELECT s.name, m.major_name
FROM student s
INNER JOIN major m ON s.major_id = m.major_id;

-- 简写形式
SELECT s.name, m.major_name
FROM student s, major m
WHERE s.major_id = m.major_id;

-- 左连接（返回左表全部，右表匹配的）
SELECT s.name, m.major_name
FROM student s
LEFT JOIN major m ON s.major_id = m.major_id;

-- 右连接（返回右表全部，左表匹配的）
SELECT s.name, m.major_name
FROM student s
RIGHT JOIN major m ON s.major_id = m.major_id;

-- 全外连接（MySQL不直接支持，用UNION模拟）
SELECT s.name, m.major_name FROM student s LEFT JOIN major m ON s.major_id = m.major_id
UNION
SELECT s.name, m.major_name FROM student s RIGHT JOIN major m ON s.major_id = m.major_id;

-- 交叉连接（笛卡尔积）
SELECT * FROM student CROSS JOIN major;

-- 自连接
SELECT a.name AS '学生', b.name AS '同班同学'
FROM student a
JOIN student b ON a.class_name = b.class_name AND a.student_no < b.student_no;

-- 多表连接
SELECT s.name, m.major_name, d.dept_name
FROM student s
JOIN major m ON s.major_id = m.major_id
JOIN department d ON m.dept_id = d.dept_id;
```

**JOIN 类型图解**：
```
A表      B表           INNER JOIN    LEFT JOIN     RIGHT JOIN
┌───┐   ┌───┐         ┌───┐         ┌───┐         ┌───┐
│ 1 │   │ 1 │         │ 1 │         │ 1 │         │ 1 │
│ 2 │   │ 2 │   →     │ 2 │         │ 2 │         │ 2 │
│ 3 │   │ 4 │                       │ 3 │         │ 4 │
└───┘   └───┘                       └───┘         └───┘
                      只有1,2       A全部+匹配     B全部+匹配
```

### 6.4 子查询

```sql
-- 标量子查询（返回单个值）
SELECT * FROM student 
WHERE age = (SELECT MAX(age) FROM student);

-- 列子查询（返回一列）
SELECT * FROM student 
WHERE major_id IN (SELECT major_id FROM major WHERE dept_id = 1);

SELECT * FROM student 
WHERE major_id NOT IN (SELECT major_id FROM major WHERE dept_id = 1);

-- EXISTS 子查询（检查是否存在）
SELECT * FROM major m
WHERE EXISTS (SELECT 1 FROM student s WHERE s.major_id = m.major_id);

SELECT * FROM major m
WHERE NOT EXISTS (SELECT 1 FROM student s WHERE s.major_id = m.major_id);

-- FROM 子句子查询（派生表）
SELECT avg_age, COUNT(*) AS major_count
FROM (
    SELECT major_id, AVG(age) AS avg_age 
    FROM student 
    GROUP BY major_id
) AS t
GROUP BY avg_age;

-- SELECT 子句子查询
SELECT 
    name,
    (SELECT COUNT(*) FROM course c WHERE c.student_no = s.student_no) AS course_count
FROM student s;

-- 关联子查询
SELECT * FROM student s1
WHERE age > (SELECT AVG(age) FROM student s2 WHERE s2.major_id = s1.major_id);
```

### 6.5 集合操作

```sql
-- 并集（去重）
SELECT name FROM student WHERE gender = '男'
UNION
SELECT name FROM student WHERE age > 20;

-- 并集（不去重）
SELECT name FROM student WHERE gender = '男'
UNION ALL
SELECT name FROM student WHERE age > 20;

-- MySQL 8.0+ 支持
-- 交集
SELECT name FROM t1 INTERSECT SELECT name FROM t2;
-- 差集
SELECT name FROM t1 EXCEPT SELECT name FROM t2;
```

---

## 七、索引

### 7.1 索引类型

| 类型 | 说明 | 创建方式 |
|------|------|----------|
| 主键索引 | 自动创建，唯一且非空 | PRIMARY KEY |
| 唯一索引 | 值必须唯一，可为NULL | UNIQUE |
| 普通索引 | 最基本的索引 | INDEX / KEY |
| 全文索引 | 用于全文搜索 | FULLTEXT |
| 联合索引 | 多列组合索引 | INDEX(a,b,c) |

### 7.2 索引操作

```sql
-- 创建索引
CREATE INDEX idx_name ON student(name);
CREATE UNIQUE INDEX uk_email ON student(email);
CREATE INDEX idx_major_gender ON student(major_id, gender);  -- 联合索引
CREATE FULLTEXT INDEX ft_content ON article(content);

-- 建表时创建
CREATE TABLE student (
    id INT PRIMARY KEY,                      -- 主键索引
    email VARCHAR(100) UNIQUE,               -- 唯一索引
    name VARCHAR(50),
    INDEX idx_name (name),                   -- 普通索引
    INDEX idx_multi (major_id, gender)       -- 联合索引
);

-- 查看索引
SHOW INDEX FROM student;

-- 删除索引
DROP INDEX idx_name ON student;
ALTER TABLE student DROP INDEX idx_name;

-- 分析查询是否使用索引
EXPLAIN SELECT * FROM student WHERE name = '张三';
```

### 7.3 索引使用原则

**应该建索引的列**：
- WHERE 条件频繁使用的列
- JOIN 关联条件列（外键）
- ORDER BY / GROUP BY 的列
- 高选择性的列（值分布均匀，重复少）

**不应建索引的列**：
- 很少查询的列
- 低选择性的列（如性别、状态）
- 频繁更新的列
- 数据量小的表

**联合索引的最左前缀原则**：
```sql
-- 创建联合索引
CREATE INDEX idx_abc ON t(a, b, c);

-- 能使用索引
WHERE a = 1
WHERE a = 1 AND b = 2
WHERE a = 1 AND b = 2 AND c = 3
WHERE a = 1 AND c = 3      -- 只用到 a

-- 不能使用索引
WHERE b = 2
WHERE c = 3
WHERE b = 2 AND c = 3
```

---

## 八、视图

### 8.1 视图操作

```sql
-- 创建视图
CREATE VIEW v_student_info AS
SELECT s.student_no, s.name, m.major_name, d.dept_name
FROM student s
JOIN major m ON s.major_id = m.major_id
JOIN department d ON m.dept_id = d.dept_id;

-- 使用视图
SELECT * FROM v_student_info;
SELECT * FROM v_student_info WHERE dept_name = '计算机系';

-- 修改视图
CREATE OR REPLACE VIEW v_student_info AS
SELECT s.student_no, s.name, s.gender, m.major_name
FROM student s
JOIN major m ON s.major_id = m.major_id;

ALTER VIEW v_student_info AS
SELECT student_no, name FROM student;

-- 查看视图
SHOW CREATE VIEW v_student_info;
SHOW FULL TABLES WHERE Table_type = 'VIEW';

-- 删除视图
DROP VIEW v_student_info;
DROP VIEW IF EXISTS v_student_info;
```

### 8.2 视图特点

- **虚拟表**：不存储数据，只存储查询语句
- **简化查询**：封装复杂SQL，简化业务代码
- **安全性**：隐藏表结构，只暴露需要的列
- **逻辑独立**：底层表变化时只需修改视图

---

## 九、存储过程与函数

### 9.1 存储过程

```sql
-- 无参数存储过程
DELIMITER //
CREATE PROCEDURE sp_get_students()
BEGIN
    SELECT * FROM student;
END //
DELIMITER ;

-- 调用
CALL sp_get_students();

-- 带 IN 参数
DELIMITER //
CREATE PROCEDURE sp_get_student_by_major(IN p_major_id INT)
BEGIN
    SELECT * FROM student WHERE major_id = p_major_id;
END //
DELIMITER ;

CALL sp_get_student_by_major(1);

-- 带 OUT 参数
DELIMITER //
CREATE PROCEDURE sp_count_students(IN p_major_id INT, OUT p_count INT)
BEGIN
    SELECT COUNT(*) INTO p_count FROM student WHERE major_id = p_major_id;
END //
DELIMITER ;

CALL sp_count_students(1, @count);
SELECT @count;

-- 带 INOUT 参数
DELIMITER //
CREATE PROCEDURE sp_double(INOUT p_num INT)
BEGIN
    SET p_num = p_num * 2;
END //
DELIMITER ;

SET @num = 5;
CALL sp_double(@num);
SELECT @num;  -- 结果: 10

-- 带流程控制的存储过程
DELIMITER //
CREATE PROCEDURE sp_check_grade(IN p_score INT, OUT p_grade VARCHAR(10))
BEGIN
    IF p_score >= 90 THEN
        SET p_grade = '优秀';
    ELSEIF p_score >= 80 THEN
        SET p_grade = '良好';
    ELSEIF p_score >= 60 THEN
        SET p_grade = '及格';
    ELSE
        SET p_grade = '不及格';
    END IF;
END //
DELIMITER ;

-- 循环示例
DELIMITER //
CREATE PROCEDURE sp_loop_demo()
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i <= 10 DO
        INSERT INTO numbers(num) VALUES(i);
        SET i = i + 1;
    END WHILE;
END //
DELIMITER ;

-- 查看存储过程
SHOW PROCEDURE STATUS WHERE Db = 'mydb';
SHOW CREATE PROCEDURE sp_get_students;

-- 删除存储过程
DROP PROCEDURE IF EXISTS sp_get_students;
```

### 9.2 自定义函数

```sql
-- 创建函数
DELIMITER //
CREATE FUNCTION fn_get_age(p_birthday DATE) RETURNS INT
DETERMINISTIC
BEGIN
    RETURN TIMESTAMPDIFF(YEAR, p_birthday, CURDATE());
END //
DELIMITER ;

-- 使用函数
SELECT name, fn_get_age(birthday) AS age FROM student;

-- 查看函数
SHOW FUNCTION STATUS WHERE Db = 'mydb';

-- 删除函数
DROP FUNCTION IF EXISTS fn_get_age;
```

**存储过程 vs 函数**：
| 特性 | 存储过程 | 函数 |
|------|----------|------|
| 返回值 | 无返回值/OUT参数 | 必须有返回值 |
| 调用方式 | CALL | SELECT中使用 |
| 事务 | 可以使用 | 不能使用 |
| 用途 | 业务逻辑处理 | 计算返回值 |

---

## 十、触发器

### 10.1 触发器操作

```sql
-- 创建触发器
DELIMITER //
CREATE TRIGGER trg_before_insert
BEFORE INSERT ON student
FOR EACH ROW
BEGIN
    SET NEW.created_at = NOW();
END //
DELIMITER ;

-- AFTER INSERT 触发器
DELIMITER //
CREATE TRIGGER trg_after_insert
AFTER INSERT ON student
FOR EACH ROW
BEGIN
    INSERT INTO log(action, student_no, time) 
    VALUES('INSERT', NEW.student_no, NOW());
END //
DELIMITER ;

-- UPDATE 触发器
DELIMITER //
CREATE TRIGGER trg_after_update
AFTER UPDATE ON student
FOR EACH ROW
BEGIN
    IF OLD.major_id != NEW.major_id THEN
        INSERT INTO change_log(student_no, old_major, new_major)
        VALUES(NEW.student_no, OLD.major_id, NEW.major_id);
    END IF;
END //
DELIMITER ;

-- DELETE 触发器
DELIMITER //
CREATE TRIGGER trg_before_delete
BEFORE DELETE ON student
FOR EACH ROW
BEGIN
    INSERT INTO deleted_students SELECT * FROM student WHERE student_no = OLD.student_no;
END //
DELIMITER ;

-- 查看触发器
SHOW TRIGGERS;
SHOW CREATE TRIGGER trg_before_insert;

-- 删除触发器
DROP TRIGGER IF EXISTS trg_before_insert;
```

### 10.2 NEW 和 OLD 关键字

| 触发事件 | NEW | OLD |
|----------|-----|-----|
| INSERT | 新行数据 | ❌ 不可用 |
| UPDATE | 更新后的数据 | 更新前的数据 |
| DELETE | ❌ 不可用 | 被删除的数据 |

---

## 十一、事务

### 11.1 事务操作

```sql
-- 开启事务
START TRANSACTION;
-- 或
BEGIN;

-- 执行SQL
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;

-- 设置保存点
START TRANSACTION;
INSERT INTO t1 VALUES(1);
SAVEPOINT sp1;
INSERT INTO t1 VALUES(2);
SAVEPOINT sp2;
INSERT INTO t1 VALUES(3);
ROLLBACK TO sp1;  -- 回滚到sp1，只保留1
COMMIT;
```

### 11.2 事务特性 (ACID)

| 特性 | 说明 |
|------|------|
| **A**tomicity（原子性） | 事务要么全部成功，要么全部失败 |
| **C**onsistency（一致性） | 事务前后数据状态一致 |
| **I**solation（隔离性） | 多个事务互不干扰 |
| **D**urability（持久性） | 提交后数据永久保存 |

### 11.3 事务隔离级别

```sql
-- 查看隔离级别
SELECT @@transaction_isolation;

-- 设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|----------|------|------------|------|
| READ UNCOMMITTED | ✅可能 | ✅可能 | ✅可能 |
| READ COMMITTED | ❌不会 | ✅可能 | ✅可能 |
| REPEATABLE READ（默认） | ❌不会 | ❌不会 | ✅可能 |
| SERIALIZABLE | ❌不会 | ❌不会 | ❌不会 |

---

## 十二、用户与权限

### 12.1 用户管理

```sql
-- 创建用户
CREATE USER 'username'@'localhost' IDENTIFIED BY 'password';
CREATE USER 'username'@'%' IDENTIFIED BY 'password';  -- 允许任何主机

-- 查看用户
SELECT user, host FROM mysql.user;

-- 修改密码
ALTER USER 'username'@'localhost' IDENTIFIED BY 'newpassword';
SET PASSWORD FOR 'username'@'localhost' = 'newpassword';

-- 删除用户
DROP USER 'username'@'localhost';
```

### 12.2 权限管理

```sql
-- 授予权限
GRANT SELECT, INSERT ON mydb.* TO 'username'@'localhost';
GRANT ALL PRIVILEGES ON mydb.* TO 'username'@'localhost';
GRANT ALL PRIVILEGES ON *.* TO 'username'@'localhost' WITH GRANT OPTION;

-- 查看权限
SHOW GRANTS FOR 'username'@'localhost';

-- 撤销权限
REVOKE INSERT ON mydb.* FROM 'username'@'localhost';
REVOKE ALL PRIVILEGES ON mydb.* FROM 'username'@'localhost';

-- 刷新权限
FLUSH PRIVILEGES;
```

**常用权限**：
| 权限 | 说明 |
|------|------|
| SELECT | 查询 |
| INSERT | 插入 |
| UPDATE | 更新 |
| DELETE | 删除 |
| CREATE | 创建表/数据库 |
| DROP | 删除表/数据库 |
| INDEX | 创建/删除索引 |
| ALTER | 修改表结构 |
| ALL PRIVILEGES | 所有权限 |

---

## 十三、常用函数

### 13.1 字符串函数

```sql
SELECT CONCAT('Hello', ' ', 'World');        -- 'Hello World'
SELECT CONCAT_WS('-', '2024', '01', '01');   -- '2024-01-01'
SELECT LENGTH('你好');                        -- 6（字节数）
SELECT CHAR_LENGTH('你好');                   -- 2（字符数）
SELECT UPPER('hello');                        -- 'HELLO'
SELECT LOWER('HELLO');                        -- 'hello'
SELECT SUBSTRING('Hello', 2, 3);              -- 'ell'
SELECT LEFT('Hello', 2);                      -- 'He'
SELECT RIGHT('Hello', 2);                     -- 'lo'
SELECT TRIM('  Hello  ');                     -- 'Hello'
SELECT LTRIM('  Hello');                      -- 'Hello'
SELECT RTRIM('Hello  ');                      -- 'Hello'
SELECT REPLACE('Hello', 'l', 'L');            -- 'HeLLo'
SELECT REVERSE('Hello');                      -- 'olleH'
SELECT REPEAT('Ha', 3);                       -- 'HaHaHa'
SELECT LPAD('5', 3, '0');                     -- '005'
SELECT RPAD('5', 3, '0');                     -- '500'
SELECT INSTR('Hello', 'l');                   -- 3（位置）
SELECT LOCATE('l', 'Hello');                  -- 3
```

### 13.2 数值函数

```sql
SELECT ABS(-10);                  -- 10
SELECT CEIL(3.14);                -- 4
SELECT FLOOR(3.99);               -- 3
SELECT ROUND(3.1415926, 2);       -- 3.14
SELECT TRUNCATE(3.1415926, 2);    -- 3.14（截断）
SELECT MOD(10, 3);                -- 1
SELECT POWER(2, 10);              -- 1024
SELECT SQRT(16);                  -- 4
SELECT RAND();                    -- 0~1随机数
SELECT GREATEST(1, 5, 3);         -- 5
SELECT LEAST(1, 5, 3);            -- 1
```

### 13.3 日期时间函数

```sql
SELECT NOW();                                    -- 当前日期时间
SELECT CURDATE();                                -- 当前日期
SELECT CURTIME();                                -- 当前时间
SELECT YEAR(NOW());                              -- 年
SELECT MONTH(NOW());                             -- 月
SELECT DAY(NOW());                               -- 日
SELECT HOUR(NOW());                              -- 时
SELECT MINUTE(NOW());                            -- 分
SELECT SECOND(NOW());                            -- 秒
SELECT DAYOFWEEK(NOW());                         -- 周几（1=周日）
SELECT WEEKDAY(NOW());                           -- 周几（0=周一）
SELECT DATE_FORMAT(NOW(), '%Y年%m月%d日');        -- 格式化
SELECT STR_TO_DATE('2024-01-01', '%Y-%m-%d');    -- 字符串转日期
SELECT DATE_ADD(NOW(), INTERVAL 7 DAY);          -- 加7天
SELECT DATE_SUB(NOW(), INTERVAL 1 MONTH);        -- 减1月
SELECT DATEDIFF('2024-12-31', '2024-01-01');     -- 日期差（天）
SELECT TIMESTAMPDIFF(YEAR, '2000-01-01', NOW()); -- 年龄
```

### 13.4 条件函数

```sql
-- IF
SELECT IF(1>0, '真', '假');                    -- '真'

-- IFNULL
SELECT IFNULL(NULL, '默认值');                 -- '默认值'
SELECT IFNULL('有值', '默认值');               -- '有值'

-- NULLIF
SELECT NULLIF(1, 1);                           -- NULL（相等返回NULL）
SELECT NULLIF(1, 2);                           -- 1（不等返回第一个）

-- COALESCE（返回第一个非NULL）
SELECT COALESCE(NULL, NULL, '第三个', '第四个'); -- '第三个'

-- CASE WHEN
SELECT 
    name,
    CASE gender
        WHEN '男' THEN 'Male'
        WHEN '女' THEN 'Female'
        ELSE 'Unknown'
    END AS gender_en
FROM student;

SELECT 
    name,
    CASE 
        WHEN age < 18 THEN '未成年'
        WHEN age < 60 THEN '成年'
        ELSE '老年'
    END AS age_group
FROM student;
```

### 13.5 聚合函数

```sql
SELECT COUNT(*) FROM student;                    -- 行数
SELECT COUNT(column) FROM student;               -- 非NULL数
SELECT COUNT(DISTINCT column) FROM student;      -- 去重计数
SELECT SUM(column) FROM student;                 -- 求和
SELECT AVG(column) FROM student;                 -- 平均
SELECT MAX(column) FROM student;                 -- 最大
SELECT MIN(column) FROM student;                 -- 最小
SELECT GROUP_CONCAT(name SEPARATOR ',') FROM student;  -- 拼接
```

### 13.6 其他函数

```sql
-- 类型转换
SELECT CAST('123' AS SIGNED);                    -- 字符串转整数
SELECT CAST(123 AS CHAR);                        -- 整数转字符串
SELECT CONVERT('123', SIGNED);                   -- 同CAST

-- 系统信息
SELECT VERSION();                                -- MySQL版本
SELECT DATABASE();                               -- 当前数据库
SELECT USER();                                   -- 当前用户
SELECT CONNECTION_ID();                          -- 连接ID
SELECT LAST_INSERT_ID();                         -- 最后插入的自增ID

-- 加密函数
SELECT MD5('password');                          -- MD5加密
SELECT SHA1('password');                         -- SHA1加密
SELECT SHA2('password', 256);                    -- SHA256加密
```

---

## 十四、性能优化

### 14.1 查询优化

```sql
-- 使用 EXPLAIN 分析查询
EXPLAIN SELECT * FROM student WHERE major_id = 1;

-- EXPLAIN 输出关键字段
-- type: 访问类型，性能从好到差：system > const > eq_ref > ref > range > index > ALL
-- key: 实际使用的索引
-- rows: 预估扫描行数
-- Extra: 额外信息（Using index、Using filesort、Using temporary等）

-- 优化建议
-- 1. 避免 SELECT *
SELECT student_no, name FROM student;  -- ✅ 只查需要的列

-- 2. 避免在索引列上使用函数
WHERE YEAR(created_at) = 2024;  -- ❌ 索引失效
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';  -- ✅

-- 3. 避免隐式类型转换
WHERE student_no = 123;  -- ❌ student_no是VARCHAR
WHERE student_no = '123';  -- ✅

-- 4. 使用 LIMIT 限制结果
SELECT * FROM student ORDER BY created_at DESC LIMIT 10;

-- 5. 避免在WHERE中使用 OR
WHERE status = 1 OR status = 2;  -- ❌ 可能不走索引
WHERE status IN (1, 2);          -- ✅
```

### 14.2 表优化

```sql
-- 分析表（更新统计信息）
ANALYZE TABLE student;

-- 优化表（整理碎片）
OPTIMIZE TABLE student;

-- 检查表
CHECK TABLE student;

-- 修复表
REPAIR TABLE student;
```

### 14.3 慢查询日志

```sql
-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;  -- 超过2秒记录
```

---

## 附录：SQL执行顺序

```sql
SELECT DISTINCT column, AGG(column)  -- 5. 选择列、去重
FROM table1                           -- 1. 确定数据源
JOIN table2 ON condition              -- 2. 连接
WHERE condition                       -- 3. 行筛选
GROUP BY column                       -- 4. 分组
HAVING condition                      -- 6. 分组筛选
ORDER BY column                       -- 7. 排序
LIMIT offset, count;                  -- 8. 限制结果
```

**执行顺序**：FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT