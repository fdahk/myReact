# 迁移异常、数据库异常，有可能是因为字符集定义差异
CREATE DATABASE paaawow CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;




# 从计算机底层原理来解释为什么"真正的同一时刻"在物理上不可能发生，以及数据库如何处理"几乎同时"的请求。
1. 计算机中不存在"绝对同时"
硬件层面的序列化
CPU 核心执行指令的最小单位是 CPU 时钟周期（纳秒级）内存总线访问是串行化的 —— 同一时刻只有一个请求能访问同一内存地址
即使是多核 CPU，当两个核心同时尝试访问/修改同一内存位置时，硬件层面会通过 缓存一致性协议（如 MESI） 和 总线仲裁 强制将它们序列化。
原子操作的硬件保证
CAS (Compare-And-Swap) 指令在 CPU 层面是原子的锁定内存总线 → 读取 → 比较 → 写入 → 解锁这个过程中其他 CPU 核心无法介入
2. 数据库锁的实现原理
数据库的行锁/表锁最终都依赖于操作系统的互斥原语（mutex），而 mutex 的核心就是 原子操作：
// 简化的锁获取逻辑（伪代码）
while (true) {    
    // 原子操作：尝试将 lock 从 0 改为 1    
    if (atomic_compare_and_swap(&lock, 0, 1) == SUCCESS) {       
         // 获取锁成功        
         break;    
        }    
    // 获取失败，自旋或休眠等待
    }
3. "同一时刻"的两个请求会怎样？
假设请求 A 和请求 B 在纳秒级别内同时到达：
时间线（放大到纳秒级）：
────────────────────────────────────────────────────
     │                    │
   请求A                请求B
   到达                  到达
     │                    │
     ▼                    ▼
   [CPU核心1]          [CPU核心2]
   执行 CAS             执行 CAS
     │                    │
     ▼                    ▼
   ┌─────────────────────────────────────┐
   │     内存总线仲裁（硬件强制序列化）    │
   │  只有一个 CAS 能成功，另一个失败      │
   └─────────────────────────────────────┘
     │                    │
     ▼                    ▼
   获取锁成功           获取锁失败
   执行操作              进入等待队列
4. 关键点总结
层级	机制	保证
CPU 硬件	总线仲裁 + 缓存一致性协议	同一内存地址的访问被强制串行化
操作系统	原子指令（CAS/XCHG）	锁状态的读写是不可分割的
数据库	基于 OS 原语的锁管理	事务获取锁的过程是原子的
5. 总结
> "如果两个请求就是同一时刻发生的呢？"
物理上不可能"同一时刻"：
即使网络包在同一微秒到达服务器
即使两个线程在同一纳秒执行锁请求
硬件总线仲裁会在皮秒级别决定谁先谁后
这不是"延迟"的问题，而是硬件层面的确定性裁决。就像两个人同时按下同一个物理按钮——分子层面总有一个先接触到。
> "延迟再短不也是延迟？"
这个"延迟"不是可被利用的漏洞，而是物理规律决定的序列化。数据库不需要"等待"来判断谁先——硬件在执行原子操作的那一刻就已经决定了结果。
类比：两辆车"同时"到达单行道入口，但入口物理上只能容纳一辆车。不存在"两辆车同时通过"的状态——物理空间本身就是互斥的。CPU 的原子操作也是如此。

---

