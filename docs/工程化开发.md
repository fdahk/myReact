常用git命令：
    1.提交现有文件夹到以建好的仓库：
        git init => git add . => git commit -m xxx => git remote add origin https://github.com/用户名/仓库名.git 
        => git branch -M main => git push -u origin main

        提交到了错误的仓库？
        git remote -v =》 法一：重置 git remote set-url origin 正确的仓库地址 
        法二：删除再添加 git remote remove origin =》 git remote add origin 正确的仓库地址
   
    2.甘特图
        甘特图（Gantt Chart）一种非常重要的项目管理工具！
            一种条形图，用来显示项目、任务或活动的时间安排。它以时间为横轴，以任务为纵轴，通过条形的长度和位置来表示任务的开始时间、持续时间和结束时间。
   
    3.kickstart 全球知名众筹平台

    4.# 假设要合并远程分支的提交 abc1234
        方法一
        git fetch origin                    # 获取远程信息
        git cherry-pick abc1234            # 合并指定提交
        git push origin your-branch        # 推送到你的分支

        方法二
        # 1. 获取远程分支
        git fetch origin

        # 2. 切换到目标分支
        git checkout your-branch

        # 3. 合并远程分支
        git merge origin/remote-branch-name

        方法三：
        # 合并远程分支的特定提交
        git cherry-pick origin/remote-branch-name~1

        推荐的工作流程：
        获取远程信息：git fetch origin
        查看提交历史：git log origin/remote-branch-name --oneline
        选择合并方式：
        单个提交：git cherry-pick <hash>
        整个分支：git merge origin/branch-name
        变基：git rebase origin/branch-name
        处理冲突：解决后继续或放弃
        推送结果：git push origin your-branch
        选择建议：
        单个提交：使用 cherry-pick
        整个功能分支：使用 merge 或 rebase
        保持历史清晰：使用 cherry-pick
        线性历史：使用 rebase

        git branch - Git 分支操作命令
        -M - 是 --move --force 的简写，表示强制移动/重命名分支
        main - 目标分支名称

    2.敏感数据处理：密钥等
        小项目: 方案二（环境变量）
        中大型项目: 方案一（服务端代理）
        企业项目: 方案三（配置服务）

    3. 出现 Invalid UTF-8 byte (at offset 0) 错误
        .env 文件是以 UTF-16 LE 编码保存的（开头的 FF FE 是 BOM），但 flutter_dotenv 期望的是 UTF-8 编码。
        Windows 系统中文件编码默认为 UTF-16 LE 的原因有几个：
        原因分析
        1. Windows 系统默认行为
        Windows PowerShell 的 echo 和 > 重定向默认使用 UTF-16 LE 编码
        这是为了兼容 Windows 的内部 Unicode 处理机制
        2. 你之前的创建方式
        当你使用类似这样的命令时：
        PowerShell 默认会以 UTF-16 LE 编码保存文件。
        3. Windows 记事本的默认行为
        如果你用 Windows 记事本创建 .env 文件，在某些版本中也可能默认保存为 UTF-16 LE。

9.8
    1.减少重排跟重绘
        1. 操作 DOM 时，尽量在低层级的 DOM 节点进行操作
        2. 不要使用 table 布局，小的改动能让table重新布局
        3. 不要频繁操作元素样式，对于静态页面，可以修改类名，而不是样式
        4. 避免频繁操作 DOM，可通过创建 documentFragment，在其应用 DOM 操作后，再添加到文档
        5. 将元素先设置为 display:none，操作结束后再将其显示
        6. 使用visiblity代替display去操作显示隐藏 


    2.合理利用浏览器缓存以提升页面的打开速度
        前端常用的缓存方案：强缓存与协商缓存相结合的方案
        1）HTML 文档配置协商缓存；
        2）JS、CSS、图片等资源配置强缓存
        此方案的好处：当项目版本更新时，可以获取最新的页面；若版本未变化，可继续复用之前的缓存资源；既很好利用了浏览器缓存，又解决了页面版本更新的问题
        如何判断强缓存过期？
            第一次访问页面，浏览器会根据服务器返回的 response Header 来判断是否对资源进行缓存，如果响应头中有 cache-control 或 expires 字段，代表该资源是强缓存


9.12
    1.husky是什么
        Husky 是一个 Git hooks 管理工具，主要用于在 Git 操作（如提交、推送等）执行前自动运行脚本。它是前端项目中非常流行的工程化工具。
        功能：
        Git Hooks 管理
        在 git commit 前运行代码检查（ESLint、Prettier）
        在 git push 前运行测试
        在提交信息中强制使用规范格式
        防止不符合规范的代码被提交
        自动格式化代码
        运行单元测试确保功能正常
        团队协作规范、统一代码风格
        强制提交信息规范、防止敏感信息泄露    
    与其他工具的配合：
        lint-staged: 只对暂存区的文件进行检查
        commitlint: 检查提交信息格式
        ESLint/Prettier: 代码质量和格式检查

    2.git rm --cached xxx 移除标记

9.22
    1.想统一使用 pnpm：先运行 pnpm setup
        全局二进制目录问题
            pnpm 与 npm 的全局安装机制不同：
            npm: 直接使用系统的全局目录（通常是 C:\Users\用户名\AppData\Roaming\npm）
            pnpm: 需要单独配置全局二进制目录和环境变量
        pnpm setup 具体做了什么
            pnpm setup 命令会执行以下关键配置：
            创建全局目录结构
            设置环境变量
            配置 shell 配置文件

    2.单仓库 Monorepo

    4.Git 有一个保护机制：
        当发现子目录有 .git 时，会将其视为 子模块 (submodule)
        不会直接追踪子仓库的内容
        显示为 "Untracked files"

    5.jest测试框架

    6.
        pnpm run format，Prettier 进行重新格式化：统一了所有文件的行结束符格式，修复了代码格式问题，移除了多余的回车符
        pnpm run lint：更严格的代码逻辑检查和代码格式检查
    
9.25
    1.开发的项目，如何确认其运行环境存在哪些限制？包括浏览器版本？SDK版本等？

    2. OAuth 鉴权方案或 SAT 鉴权方案 PAT 鉴权

    3.环境变量的原理，修改环境变量后需要重启开发服务器？

    4.process is not defined 是因为在浏览器环境中无法直接访问 Node.js 的 process 对象。这是 Vite 构建工具的一个特性
        1. 配置 Vite 以支持 process.env
        2.Vite 推荐使用 import.meta.env 而不是 process.env （Node.js 环境也使用 process.env 来访问环境变量
        3.Vite 环境变量规则
        React (Create React App) vs Vite 的区别：
        项目类型	环境变量前缀	访问方式
        Create React App	REACT_APP_	process.env.REACT_APP_*
        Vite	VITE_	import.meta.env.VITE_*

9.28:
    1.单分支并行推送，冲突处理
        合并策略 git pull --rebase=false origin JiangTu
        变基策略 git pull --rebase origin JiangTu


### Docker：
    # 传统开发方式
        npm install          # 本地安装依赖
        npm run dev         # 本地启动服务
        # 直接编辑代码，保存即生效

    # Docker开发方式
        docker-compose up -d              # 启动开发环境
        docker-compose logs -f api        # 查看日志
        docker-compose exec api bash      # 进入容器调试
        docker-compose restart api        # 重启服务
        docker-compose down               # 停止环境

        # 安装新依赖时
        docker-compose exec api npm install package-name
        docker-compose restart api

        # 运行数据库操作
        docker-compose exec postgres psql -U dev -d myapp_dev

        # 清理环境
        docker-compose down -v            # 删除数据卷
        docker system prune -f            # 清理Docker缓存

    学习的额外知识
        Docker基础概念：镜像、容器、卷、网络
        Docker Compose：服务编排、依赖管理
        容器调试：如何进入容器、查看日志、排查问题
        环境变量管理：不同环境的配置管理
        数据持久化：卷挂载、数据备份恢复

    部署脚本
        #!/bin/bash
        # deploy.sh

        # 拉取最新镜像
        docker-compose -f docker-compose.prod.yml pull

        # 滚动更新
        docker-compose -f docker-compose.prod.yml up -d --no-deps api

        # 健康检查
        ./scripts/health-check.sh

        # 清理旧镜像
        docker image prune -f

所有成员需要学习：
Docker基础概念（2天）
容器 vs 虚拟机
镜像、容器、仓库概念
Docker基本命令
Dockerfile编写规则
Docker Compose使用（1天）
多服务编排
环境变量管理
数据卷使用
网络配置
实践练习（2天）
本地安装Docker环境
运行官方示例项目
编写简单的Dockerfile
阶段二：环境准备（第2周）
2.1 开发环境安装
每个开发人员需要做：
Windows用户：
步骤：
1. 下载Docker Desktop for Windows
   - 访问：https://www.docker.com/products/docker-desktop
   - 下载安装包并安装
   - 重启电脑

2. 验证安装
   - 打开PowerShell或CMD
   - 运行：docker --version
   - 运行：docker-compose --version
   - 运行：docker run hello-world

3. 配置资源限制
   - 打开Docker Desktop设置
   - Resources → Advanced
   - 分配至少4GB内存，2个CPU核心

步骤：
1. 下载Docker Desktop for Mac
2. 安装.dmg文件
3. 验证安装（同Windows）
4. 配置资源（同Windows）

2.2 项目结构规划
项目架构师/技术负责人需要设计：
项目目录结构：
your-project/
├── backend/                    # 后端代码
│   ├── src/
│   ├── package.json
│   ├── Dockerfile             # 后端生产镜像
│   └── Dockerfile.dev         # 后端开发镜像
├── frontend/                   # Flutter前端（保持现有结构）
├── docker/                     # Docker相关配置
│   ├── nginx/
│   │   └── nginx.conf
│   └── postgres/
│       └── init.sql
├── docker-compose.yml          # 开发环境
├── docker-compose.prod.yml     # 生产环境
├── docker-compose.test.yml     # 测试环境
├── .env.example               # 环境变量模板
├── .env.development           # 开发环境变量
├── .dockerignore              # Docker忽略文件
└── scripts/
    ├── setup.sh               # 环境初始化脚本
    └── cleanup.sh             # 清理脚本

阶段三：配置文件创建（第3周）
3.1 后端Dockerfile创建
后端开发负责人需要创建：
Dockerfile.dev（开发环境）
# 根据你们的技术栈选择基础镜像
# Node.js示例：
FROM node:18-alpine

WORKDIR /app

# 安装开发工具
RUN npm install -g nodemon

# 复制依赖文件
COPY package*.json ./
RUN npm install

# 暴露端口
EXPOSE 3000

# 开发模式启动（支持热重载）
CMD ["npm", "run", "dev"]

Dockerfile（生产环境）
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM node:18-alpine AS production
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodeuser -u 1001

WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json

USER nodeuser
EXPOSE 3000

CMD ["node", "dist/server.js"]

3.2 Docker Compose配置
DevOps负责人需要创建：
docker-compose.yml（开发环境）
version: '3.8'

services:
  # 后端API服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      # 代码热重载
      - ./backend/src:/app/src
      - ./backend/package.json:/app/package.json
      - backend_node_modules:/app/node_modules
    environment:
      - NODE_ENV=development
      - DB_HOST=postgres
      - REDIS_HOST=redis
    env_file:
      - .env.development
    depends_on:
      - postgres
      - redis

  # 数据库
  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: ${DB_NAME:-myapp_dev}
      POSTGRES_USER: ${DB_USER:-dev}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-dev123}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql

  # 缓存
  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # 数据库管理工具（可选）
  pgadmin:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com
      PGADMIN_DEFAULT_PASSWORD: admin
    ports:
      - "5050:80"
    depends_on:
      - postgres

volumes:
  postgres_data:
  redis_data:
  backend_node_modules:


3.3 环境变量配置
每个环境负责人需要创建：
.env.example（模板文件）
# 数据库配置
DB_HOST=postgres
DB_PORT=5432
DB_NAME=myapp_dev
DB_USER=dev
DB_PASSWORD=dev123

# Redis配置
REDIS_HOST=redis
REDIS_PORT=6379

# 应用配置
NODE_ENV=development
PORT=3000
JWT_SECRET=your-jwt-secret

# 第三方服务
API_KEY=your-api-key


3.4 忽略文件配置
项目维护人员需要创建：
.dockerignore


阶段四：开发流程迁移（第4-5周）
4.1 开发环境搭建
每个开发人员需要执行：
# 1. 克隆项目（如果还没有）
git clone your-project-repo
cd your-project

# 2. 复制环境变量文件
cp .env.example .env.development
# 根据实际情况修改.env.development中的值

# 3. 首次构建（可能需要10-30分钟）
docker-compose build

# 4. 启动开发环境
docker-compose up -d

# 5. 检查服务状态
docker-compose ps

# 6. 查看日志
docker-compose logs backend

# 7. 测试API连接
curl http://localhost:3000/health


4.2 日常开发工作流
开发人员日常操作：
启动开发环境：
# 每天开始工作时
docker-compose up -d

# 查看所有服务状态
docker-compose ps

# 查看特定服务日志
docker-compose logs -f backend

代码开发：
# 代码修改会自动热重载（如果配置了volume挂载）
# 直接在IDE中修改代码即可

# 如果需要安装新的npm包
docker-compose exec backend npm install package-name

# 重启服务使新包生效
docker-compose restart backend

数据库操作：
# 连接数据库
docker-compose exec postgres psql -U dev -d myapp_dev

# 运行数据库迁移
docker-compose exec backend npm run migrate

# 重置数据库
docker-compose exec postgres psql -U dev -d myapp_dev -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"

调试和排错：
# 进入后端容器调试
docker-compose exec backend sh

# 查看容器内文件
docker-compose exec backend ls -la /app

# 查看环境变量
docker-compose exec backend printenv

# 重启特定服务
docker-compose restart backend

# 完全重建服务
docker-compose up -d --build backend
结束工作：
# 停止服务但保留数据
docker-compose stop

# 停止服务并删除容器（保留数据卷）
docker-compose down

# 停止服务并删除所有数据（谨慎使用）
docker-compose down -v


阶段五：CI/CD集成（第6周）
5.1 版本控制集成
DevOps工程师需要配置：
GitHub Actions配置（.github/workflows/ci.yml）

name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: docker.io
  IMAGE_NAME: your-company/your-app

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Create test environment file
      run: |
        cp .env.example .env.test
        # 设置测试环境变量

    - name: Run tests
      run: |
        docker-compose -f docker-compose.test.yml build
        docker-compose -f docker-compose.test.yml up -d
        docker-compose -f docker-compose.test.yml exec -T backend npm test
        docker-compose -f docker-compose.test.yml down

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v3
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}


5.2 部署脚本
运维人员需要创建：
scripts/deploy.sh

#!/bin/bash

set -e

echo "开始部署..."

# 拉取最新代码
git pull origin main

# 拉取最新镜像
docker-compose -f docker-compose.prod.yml pull

# 备份数据库
docker-compose -f docker-compose.prod.yml exec postgres \
  pg_dump -U produser proddb > backup_$(date +%Y%m%d_%H%M%S).sql

# 滚动更新
docker-compose -f docker-compose.prod.yml up -d --no-deps backend

# 等待服务就绪
echo "等待服务启动..."
sleep 10

# 健康检查
if curl -f http://localhost:3000/health; then
    echo "部署成功！"
else
    echo "健康检查失败，回滚..."
    docker-compose -f docker-compose.prod.yml rollback backend
    exit 1
fi

# 清理旧镜像
docker image prune -f

echo "部署完成！"


阶段六：团队协作流程（第7周）
6.1 代码协作流程
新功能开发流程：
开发人员操作：
# 1. 创建功能分支
git checkout -b feature/new-feature

# 2. 启动开发环境
docker-compose up -d

# 3. 开发功能
# ... 编写代码 ...

# 4. 本地测试
docker-compose exec backend npm test

# 5. 提交代码
git add .
git commit -m "Add new feature"
git push origin feature/new-feature


代码审查流程：
# 1. 创建Pull Request
# 2. CI自动运行测试
# 3. 团队成员代码审查
# 4. 合并到develop分支
测试环境部署：
# 自动触发测试环境部署
# 测试人员进行功能验证
生产环境发布：
# 合并到main分支
# 自动构建生产镜像
# 执行部署脚本


6.2 环境管理规范
环境负责人分工：
开发环境：每个开发者自己管理
测试环境：测试团队负责人管理
生产环境：DevOps工程师管理
数据管理规范：
# 开发环境：可以随时重置
docker-compose down -v
docker-compose up -d

# 测试环境：定期重置，导入标准测试数据
# 生产环境：严格备份，谨慎操作


阶段七：监控和维护（第8周及以后）
7.1 日常维护任务
每周维护清单：
# 1. 清理Docker资源
docker system prune -f

# 2. 更新基础镜像
docker-compose pull

# 3. 检查日志大小
docker-compose logs --tail=100 backend

# 4. 备份重要数据
docker-compose exec postgres pg_dump -U user dbname > backup.sql


.2 性能监控
监控指标：
容器资源使用情况
应用响应时间
数据库连接数
错误日志统计
监控命令：
# 查看资源使用
docker stats

# 查看容器详情
docker-compose top

# 查看网络连接
docker network ls
docker network inspect project_default


总体时间规划（8周计划）
周次	主要任务	负责人	交付物
第1周	现状调研、团队培训	全员	调研报告、培训材料
第2周	环境安装、结构设计	全员	本地Docker环境
第3周	配置文件创建	技术负责人	完整配置文件
第4周	开发环境搭建	开发人员	可运行的开发环境
第5周	并行开发试运行	开发人员	功能验证
第6周	CI/CD集成	DevOps	自动化流水线
第7周	团队协作流程	全员	标准化流程
第8周	生产环境迁移	DevOps	生产环境上线


应急回滚方案
# 如果Docker化遇到严重问题，快速回滚到原方式
# 1. 停止Docker服务
docker-compose down

# 2. 启动原有服务
# 恢复原有的服务启动脚本

# 3. 数据恢复
# 从备份恢复数据库


# 单元测试原理

❌ Golden Tests（截图测试）
❌ 性能测试
❌ 内存泄漏测试
❌ 复杂的CI/CD配置
❌ Widget测试（暂时不要求）
❌ 集成测试（暂时不要求）
✅ API服务测试（最重要）
✅ Provider测试（状态管理）
✅ 业务服务测试（核心逻辑）
✅ 工具类测试

## Golden Tests（截图测试）

## Golden Tests（截图测试）

## CI/CD测试配置
1.GitHub Actions配置
2.配置文件
你的项目/
└── .github/
    └── workflows/           # 工作流文件夹
        ├── test.yml         # 测试工作流
        ├── deploy.yml       # 部署工作流
        └── lint.yml         # 代码检查工作流