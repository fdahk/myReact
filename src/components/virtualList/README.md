1.VirtualListProps<T> {data: T[];} //泛型参数，指定类型, 使用时
    any[] Array<any> Array<unkown> 等都不推荐
2.顶部占位高度计算方法 startIndex * itemHeight，不是 topOffset
    为什么：
3.虚拟列表的哪些值采用纯计算，不使用useState等函数包装 
    “纯计算、没有副作用，只依赖于已知变量”的数据 均采用 纯计算 
        只要依赖的变量变了，这个值就会自动变，不需要手动去更新它
            响应式数据触发重新渲染，会重新执行组件内所有代码
            如果你希望某些计算只有依赖变化时才重新计算，可以用 useMemo 或 useCallback
            响应式数据：只有你调用 setCount，count 才会变，重新渲染等都不会变
        副作用指：影响外部环境（组件渲染之外）、需要异步处理、要手动触发更新的操作（比如发请求、操作 DOM、定时器等），
            纯计算的值不会影响外部环境，也不依赖外部环境，只和输入有关
        只有副作用才需要用 useEffect，只有需要手动维护的状态才用 useState
4.虚拟列表组件的样式设计：
    宽高在引用处决定
5.getItemKey在虚拟列表中至关重要：
    计算渲染当前渲染元素的key，避免 React diff算法计算出错（比如滚动时 key 重复等问题）
    getItemKey的计算不当会导致验证的渲染问题
6.原始data数据 和 加工后的 virtualItems 的一个处理
7.由于使用时传来的数据可以是任何形式，虚拟列表在渲染时并不知道 数据中有什么值
    需要再传一个renderItem 的props 值
    由用户自定义item渲染方式
8.元素没有实现宽度撑开容器:
    在 column 的 flex 容器中，默认情况下，容器的宽度不会被子元素撑开，而是会收缩到父级或自身的宽度（如果没设置宽度，通常是 100% 度）。
        如果父级（如 .box 或 .container）宽度有限制，.virtual_list 就不会超出父级宽度
        column; 下，flex 容器的宽度默认是“填满父容器”，不会被内容撑开
    在column 下，子项的宽度默认是“自动填满父容器”，而不是撑开父容器。
        如果子项宽度大于父容器，子项会溢出，但父容器不会变宽，除非你设置 min-width: max-content
    解决方案：容器设置：min-width: max-content; 
9.在组件开发中，应该遵循外部可以控制组件 最外层容器的大小，容器内部的设计以最外层容器为基准
    可以避免滚动条与元素内容共占内容区的问题

性能优化：
    data.slice(startIndex, endIndex) 可以用 useMemo 缓存，避免每次渲染都重新 slice
    滚动事件可以用 requestAnimationFrame 或 throttle 优化，避免高频 setState 导致卡顿

    浏览器的 scroll 事件触发频率非常高，在快速滚动时，可能每 1~2ms 就触发一次
         throttle（节流）优化（这个需要自己实现或者下包）：节流的原理是：在一段时间内只允许函数执行一次，比如每 16ms（约等于 60fps）只执行一次
    requestAnimationFrame（浏览器原生） 是浏览器专门为动画和高频 UI 更新设计的 API。
        它会在下一帧渲染前自动合并多次调用，只执行一次回调，保证每一帧最多只更新一次。
        这样可以让滚动和渲染节奏与浏览器刷新率同步，更流畅、更高效
10.滚动更新失效问题：
    在 requestAnimationFrame 的回调里，e 事件对象已经不是原来的那个，或者已经被 React 事件池回收
        React 的事件对象是“合成事件”，在异步回调中会被回收，不能直接用
        先把需要的值（如 scrollTop）取出来，传给异步回调，才能保证数据正确