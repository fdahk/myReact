<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL 3D Cube</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #webgl-canvas {
            border: 1px solid #333;
            background: #111;
        }
    </style>
</head>
<body>
    <canvas id="webgl-canvas" width="500" height="500"></canvas>
</body>
<script>
    // WebGL着色器代码
const vertexShaderSource = `
    attribute vec4 a_position;
    attribute vec4 a_color;
    uniform mat4 u_matrix;
    varying vec4 v_color;
    
    void main() {
        gl_Position = u_matrix * a_position;
        v_color = a_color;
    }
`;

const fragmentShaderSource = `
    precision mediump float;
    varying vec4 v_color;
    
    void main() {
        gl_FragColor = v_color;
    }
`;

class WebGLCube {
    constructor(canvas) {
        console.log('Initializing WebGL...');
        this.gl = canvas.getContext('webgl');
        if (!this.gl) {
            console.error('WebGL not supported!');
            alert('WebGL not supported!');
            return;
        }
        console.log('WebGL context created');
        
        // 设置视口
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.clearColor(0.1, 0.1, 0.1, 1.0); // 稍微亮一点的背景
        console.log('Viewport set to:', canvas.width, 'x', canvas.height);
        
        this.program = this.createProgram();
        if (!this.program) {
            console.error('Failed to create shader program');
            return;
        }
        console.log('Shader program created successfully');
        
        this.setupGeometry();
        this.rotation = 0;
        console.log('WebGL initialization complete');
    }
    
    createProgram() {
        const gl = this.gl;
        const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        if (!vertexShader || !fragmentShader) {
            return null;
        }
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        // 检查链接错误
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        
        return program;
    }
    
    createShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        // 检查编译错误
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        
        return shader;
    }
    
    setupGeometry() {
        const gl = this.gl;
        
        // 完整立方体的24个顶点 (每个面4个顶点，6个面)
        const vertices = new Float32Array([
            // 前面 - 红色
            -0.5, -0.5,  0.5,  1, 0, 0, 1,  // 0
             0.5, -0.5,  0.5,  1, 0, 0, 1,  // 1
             0.5,  0.5,  0.5,  1, 0, 0, 1,  // 2
            -0.5,  0.5,  0.5,  1, 0, 0, 1,  // 3
            
            // 后面 - 绿色
            -0.5, -0.5, -0.5,  0, 1, 0, 1,  // 4
             0.5, -0.5, -0.5,  0, 1, 0, 1,  // 5
             0.5,  0.5, -0.5,  0, 1, 0, 1,  // 6
            -0.5,  0.5, -0.5,  0, 1, 0, 1,  // 7
            
            // 左面 - 蓝色
            -0.5, -0.5, -0.5,  0, 0, 1, 1,  // 8
            -0.5, -0.5,  0.5,  0, 0, 1, 1,  // 9
            -0.5,  0.5,  0.5,  0, 0, 1, 1,  // 10
            -0.5,  0.5, -0.5,  0, 0, 1, 1,  // 11
            
            // 右面 - 黄色
             0.5, -0.5, -0.5,  1, 1, 0, 1,  // 12
             0.5, -0.5,  0.5,  1, 1, 0, 1,  // 13
             0.5,  0.5,  0.5,  1, 1, 0, 1,  // 14
             0.5,  0.5, -0.5,  1, 1, 0, 1,  // 15
            
            // 上面 - 紫色
            -0.5,  0.5, -0.5,  1, 0, 1, 1,  // 16
             0.5,  0.5, -0.5,  1, 0, 1, 1,  // 17
             0.5,  0.5,  0.5,  1, 0, 1, 1,  // 18
            -0.5,  0.5,  0.5,  1, 0, 1, 1,  // 19
            
            // 下面 - 青色
            -0.5, -0.5, -0.5,  0, 1, 1, 1,  // 20
             0.5, -0.5, -0.5,  0, 1, 1, 1,  // 21
             0.5, -0.5,  0.5,  0, 1, 1, 1,  // 22
            -0.5, -0.5,  0.5,  0, 1, 1, 1,  // 23
        ]);
        
        console.log('Complete cube vertex data created, length:', vertices.length);
        
        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        // 完整立方体的索引 - 6个面，每个面2个三角形
        const indices = new Uint16Array([
            // 前面
            0, 1, 2,   0, 2, 3,
            // 后面
            4, 6, 5,   4, 7, 6,
            // 左面
            8, 9, 10,  8, 10, 11,
            // 右面
            12, 14, 13, 12, 15, 14,
            // 上面
            16, 17, 18, 16, 18, 19,
            // 下面
            20, 22, 21, 20, 23, 22
        ]);
        
        console.log('Complete cube index data created, length:', indices.length);
        
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        
        this.indexCount = indices.length;
    }
    
    render() {
        const gl = this.gl;
        
        // 清空画布
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        // 启用深度测试，3D渲染必需
        gl.enable(gl.DEPTH_TEST);
        
        // 使用着色器程序
        gl.useProgram(this.program);
        
        // 绑定顶点数据
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        
        const positionLocation = gl.getAttribLocation(this.program, 'a_position');
        const colorLocation = gl.getAttribLocation(this.program, 'a_color');
        
        if (positionLocation === -1 || colorLocation === -1) {
            console.error('Failed to get attribute locations', positionLocation, colorLocation);
            return;
        }
        
        // 位置属性
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 7 * 4, 0);
        
        // 颜色属性
        gl.enableVertexAttribArray(colorLocation);
        gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 7 * 4, 3 * 4);
        
        // 创建变换矩阵
        const matrix = this.createTransformMatrix();
        const matrixLocation = gl.getUniformLocation(this.program, 'u_matrix');
        if (matrixLocation === null) {
            console.error('Failed to get matrix uniform location');
            return;
        }
        gl.uniformMatrix4fv(matrixLocation, false, matrix);
        
        // 绘制立方体
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
        
        // 检查WebGL错误
        const error = gl.getError();
        if (error !== gl.NO_ERROR) {
            console.error('WebGL error:', error);
        }
        
        // 第一帧输出调试信息
        if (this.rotation === 0) {
            console.log('First frame rendered');
            console.log('Position location:', positionLocation);
            console.log('Color location:', colorLocation);
            console.log('Matrix location:', matrixLocation);
            console.log('Index count:', this.indexCount);
        }
        
        // 更新旋转角度
        this.rotation += 0.02;
        requestAnimationFrame(() => this.render());
    }
    
    createTransformMatrix() {
        // 同时绕X轴和Y轴旋转，展示3D效果
        const rotX = this.rotation * 0.7;  // X轴旋转稍慢
        const rotY = this.rotation;        // Y轴旋转
        
        const cosX = Math.cos(rotX);
        const sinX = Math.sin(rotX);
        const cosY = Math.cos(rotY);
        const sinY = Math.sin(rotY);
        
        // X轴旋转矩阵
        const rotationX = [
            1, 0, 0, 0,
            0, cosX, -sinX, 0,
            0, sinX, cosX, 0,
            0, 0, 0, 1
        ];
        
        // Y轴旋转矩阵
        const rotationY = [
            cosY, 0, sinY, 0,
            0, 1, 0, 0,
            -sinY, 0, cosY, 0,
            0, 0, 0, 1
        ];
        
        // 缩放矩阵
        const scale = [
            0.7, 0, 0, 0,
            0, 0.7, 0, 0,
            0, 0, 0.7, 0,
            0, 0, 0, 1
        ];
        
        // 组合变换：缩放 * Y旋转 * X旋转
        const temp = this.multiplyMatrices(rotationY, rotationX);
        const final = this.multiplyMatrices(scale, temp);
        
        return new Float32Array(final);
    }
    
    // 4x4矩阵相乘
    multiplyMatrices(a, b) {
        const result = new Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                result[i * 4 + j] = 
                    a[i * 4 + 0] * b[0 * 4 + j] +
                    a[i * 4 + 1] * b[1 * 4 + j] +
                    a[i * 4 + 2] * b[2 * 4 + j] +
                    a[i * 4 + 3] * b[3 * 4 + j];
            }
        }
        return result;
    }
}

// 使用
const canvas = document.getElementById('webgl-canvas');
console.log('Canvas found:', canvas);
console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);

const cube = new WebGLCube(canvas);

// 确保WebGL初始化成功后再开始渲染
if (cube.gl && cube.program) {
    console.log('WebGL initialized successfully');
    cube.render();
} else {
    console.error('WebGL initialization failed');
    console.log('GL context:', cube.gl);
    console.log('Program:', cube.program);
    document.body.innerHTML += '<p style="color: red; text-align: center;">WebGL not supported or initialization failed!</p>';
}
</script>
</html>